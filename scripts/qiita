#!/usr/bin/env python

# -----------------------------------------------------------------------------
# Copyright (c) 2014--, The Qiita Development Team.
#
# Distributed under the terms of the BSD 3-clause License.
#
# The full license is in the file LICENSE, distributed with this software.
# -----------------------------------------------------------------------------
from __future__ import division, print_function

import errno
import socket
from datetime import datetime, timedelta

import click
import tornado.httpserver
import tornado.ioloop
from psycopg2 import OperationalError
from future.utils import viewitems
from os.path import join, abspath, dirname

from qiita_db.util import (get_filepath_types, get_filetypes,
                           get_data_types,
                           get_processed_params_tables,
                           get_preprocessed_params_tables)
from qiita_db.commands import (load_sample_template_from_cmd,
                               load_study_from_cmd,
                               load_raw_data_cmd, load_processed_data_cmd,
                               load_preprocessed_data_from_cmd,
                               load_prep_template_from_cmd,
                               load_parameters_from_cmd, SUPPORTED_PARAMS,
                               update_preprocessed_data_from_cmd)
from qiita_db.portal import Portal
from qiita_db.sql_connection import SQLConnectionHandler
from qiita_db.exceptions import QiitaDBConnectionError, QiitaDBError
from qiita_db.reference import Reference
from qiita_db.logger import LogEntry
from qiita_db.util import add_system_message, clear_system_messages
from qiita_core.qiita_settings import qiita_config
from qiita_ware.ebi import EBISubmission
from qiita_ware.commands import submit_EBI as _submit_EBI
from qiita_ware.processing_pipeline import generate_demux_file
from qiita_ware.context import system_call, ComputeError
from moi import r_client


try:
    conn = SQLConnectionHandler()
except OperationalError:
    raise QiitaDBConnectionError("Database does not exist. See qiita-env "
                                 "make --help for more information")
else:
    del conn


@click.group()
def qiita():
    pass


@qiita.group()
def pet():
    pass


@pet.group(invoke_without_command=True)
@click.option('--build-docs/--no-build-docs', default=True, help="Controls "
              "whether the docs are built and moved to the 'doc' folder under "
              "the 'static' folder.")
def webserver(build_docs):
    if build_docs:
        import qiita_pet

        base = abspath(dirname(qiita_pet.__file__))
        sphinx_fp = join(base, 'support_files/doc/')
        cmd = 'make -C %s html' % sphinx_fp
        print('Building documentation ...')
        try:
            system_call(cmd)
        except ComputeError as e:
            raise click.ClickException('Could not build documentation: %s' %
                                       str(e))
        else:
            print('Documentation successfully built')


@qiita.group()
def db():
    pass


@qiita.group()
def maintenance():
    pass


@qiita.group()
def ware():
    pass


@ware.group()
def ebi():
    pass


@db.group()
def portal():
    pass

# #############################################################################
# DB COMMANDS
# #############################################################################


@db.command()
@click.option('--owner', required=True,
              help="The email address of the owner of the study")
@click.option('--title', help="The title of the study", required=True)
@click.option('--info', type=click.File(mode='r'), required=True,
              help="filepath of file with study information in python "
              "config file format")
def load_study(owner, title, info):
    """Loads a study to the database"""
    study = load_study_from_cmd(owner, title, info)
    click.echo("Study successfully added to the database with id %s"
               % study.id)


@db.command()
@click.option('--fp', required=True, type=click.Path(resolve_path=True,
              readable=True, exists=True), multiple=True,
              help='Path to the raw data file. This option can be used '
              'multiple times if there are multiple raw data files.')
@click.option('--fp_type', required=True, multiple=True, help='Describes the '
              'contents of the file. Pass one fp_type per fp.',
              type=click.Choice(get_filepath_types().keys()))
@click.option('--filetype', required=True,
              type=click.Choice(get_filetypes().keys()),
              help='The type of data')
@click.option('--prep_template', multiple=True, help='Associate the data with '
              'this prep template. This option can be used multiple times if '
              'the data should be associated with multiple prep templates',
              type=int, required=True)
def load_raw(fp, fp_type, filetype, prep_template):
    """Loads a raw data to the database"""
    raw_data = load_raw_data_cmd(fp, fp_type, filetype, prep_template)
    click.echo("Raw data successfully added to the database with id %s"
               % raw_data.id)


@db.command()
@click.option('--study_id', help="Study id associated with data",
              required=True)
@click.option('--params_table', help="Name of the paramaters table for the "
              "preprocessed data", required=True,
              type=click.Choice(get_preprocessed_params_tables()))
@click.option('--filedir', help="Directory containing preprocessed data",
              required=True)
@click.option('--filepathtype', help="Describes the contents of the input "
              "files", required=True,
              type=click.Choice(get_filepath_types().keys()))
@click.option('--params_id', required=True,
              help="id in the paramater table associated with the parameters")
@click.option('--prep_template_id',
              help="Prep template id associated with data", default=None)
@click.option('--insdc', is_flag=True,
              help="If provided, the preprocessed data have been submitted "
                   "to insdc")
@click.option('--data_type', default=None,
              type=click.Choice(get_data_types()),
              help="The data type of data")
def load_preprocessed(study_id, params_table, filedir, filepathtype,
                      params_id, prep_template_id, insdc, data_type):
    """Loads a preprocessed data to the database"""
    preproc_data = load_preprocessed_data_from_cmd(
        study_id, params_table, filedir, filepathtype, params_id, insdc,
        prep_template_id, data_type)
    click.echo("Preprocessed data successfully added to the database with "
               "id %s" % preproc_data.id)


@db.command()
@click.option('--fp', required=True, type=click.Path(resolve_path=True,
              readable=True, exists=True), multiple=True, help='Path to the '
              'processed data. This option can be used multilpe times if '
              'there are multiple processed data files.')
@click.option('--fp_type', required=True, multiple=True, help='Describes the '
              'contents of the file. Pass one fp_type per fp.',
              type=click.Choice(get_filepath_types().keys()))
@click.option('--processed_params_table', required=True,
              type=click.Choice(get_processed_params_tables()),
              help='The table containing the processed parameters used to '
              'generate this file')
@click.option('--processed_params_id', required=True, type=int,
              help='The ID of the row in the processed_params table')
@click.option('--preprocessed_data_id', type=int, default=None, help='The '
              'ID of the row in the preprocessed_data table from which '
              'this processed data was created')
@click.option('--study_id', type=int, default=None, help='The '
              'ID of the row in the study table to which this processed data '
              'belongs')
@click.option('--processed_date', type=str, default=None,
              help='The date to use as the processed_date. Must be '
              'interpretable  as a datetime. If None, then the current date '
              'and time will be used.')
def load_processed(fp, fp_type, processed_params_table,
                   processed_params_id, preprocessed_data_id, study_id,
                   processed_date):
    """Loads a processed data to the database"""
    proc_data = load_processed_data_cmd(fp, fp_type, processed_params_table,
                                        processed_params_id,
                                        preprocessed_data_id, study_id,
                                        processed_date)
    click.echo("Processed data successfully added to the database with id %s"
               % proc_data.id)


@db.command()
@click.argument('fp', required=True,
                type=click.Path(resolve_path=True, readable=True, exists=True))
@click.option('--study', required=True, type=int,
              help='Associate the sample template with this study')
def load_sample_template(fp, study):
    """Loads a sample template to the database"""
    sample_temp = load_sample_template_from_cmd(fp, study)
    click.echo("Sample template successfully added to the database with id %s"
               % sample_temp.id)


@db.command()
@click.argument('fp', required=True,
                type=click.Path(resolve_path=True, readable=True, exists=True))
@click.option('--study', required=True, type=int,
              help='Associate the prep template with this study')
@click.option('--data_type', required=True,
              type=click.Choice(get_data_types()),
              help="The data type of data")
def load_prep_template(fp, study, data_type):
    """Loads a sample template to the database"""
    prep_template = load_prep_template_from_cmd(fp, study, data_type)
    click.echo("Prep template successfully added to the database with id %s"
               % prep_template.id)


@db.command()
@click.option('--name', required=True, type=str,
              help='The name of the new reference database')
@click.option('--version', required=True, type=str,
              help='The version of the reference database')
@click.option('--seq_fp', required=True,
              type=click.Path(resolve_path=True, readable=True, exists=True),
              help="Path to the reference sequences file")
@click.option('--tax_fp', required=False,
              type=click.Path(resolve_path=True, readable=True, exists=True),
              help="Path to the reference taxonomy file")
@click.option('--tree_fp', required=False,
              type=click.Path(resolve_path=True, readable=True, exists=True),
              help="Path to the reference tree file")
def load_reference_db(name, version, seq_fp, tax_fp, tree_fp):
    """Loads a reference db to the database"""
    reference = Reference.create(name, version, seq_fp, tax_fp, tree_fp)
    click.echo("Reference db successfully added to the database with id %s"
               % reference.id)


@db.command()
@click.argument('fp', required=True,
                type=click.Path(resolve_path=True, readable=True, exists=True))
@click.option('--table', required=True, type=click.Choice(SUPPORTED_PARAMS),
              help='The table to add the parameter set')
@click.option('--name', required=True, type=str,
              help='The name of the parameters set')
def load_parameters(fp, table, name):
    """Loads a parameter set to the database"""
    param = load_parameters_from_cmd(name, fp, table)
    click.echo("Parameters successfully added to table %s with id %s"
               % (table, param.id))


@db.command()
@click.argument('sl_out_dir', required=True,
                type=click.Path(resolve_path=True, readable=True, exists=True,
                                file_okay=False))
@click.option('--study', required=True, type=int,
              help='Study whose preprocessed data will be updated')
@click.option('--preprocessed_data', required=False, type=int,
              help='Preprocessed data to be updated. If not passed, the '
                   'preprocessed data with lowest id in the study will '
                   'be updated.')
def update_preprocessed_data(sl_out_dir, study,  preprocessed_data):
    """Updates the study with the preprocessed data in sl_out_dir"""
    ppd = update_preprocessed_data_from_cmd(sl_out_dir, study,
                                            preprocessed_data)
    click.echo("Preprocessed data %s successfully updated" % ppd.id)

# #############################################################################
# PORTAL COMMANDS
# #############################################################################


@portal.command(name="add-analyses")
@click.argument('portal', required=True,
                type=click.Choice(Portal.list_portals()))
@click.argument('analyses', required=True, type=int, nargs=-1)
def add_analysis(portal, analyses):
    try:
        Portal(portal).add_analyses(analyses)
    except QiitaDBError as e:
        raise click.BadOptionUsage("analyses", str(e))


@portal.command(name="remove-analyses")
@click.argument('portal', required=True,
                type=click.Choice(Portal.list_portals()))
@click.argument('analyses', required=True, type=int, nargs=-1)
def remove_analysis(portal, analyses):
    try:
        Portal(portal).remove_analyses(analyses)
    except QiitaDBError as e:
        raise click.BadOptionUsage("analyses", str(e))


@portal.command(name="add-studies")
@click.argument('portal', required=True,
                type=click.Choice(Portal.list_portals()))
@click.argument('studies', required=True, type=int, nargs=-1)
def add_study(portal, studies):
    try:
        Portal(portal).add_studies(studies)
    except QiitaDBError as e:
        raise click.BadOptionUsage("studies", str(e))


@portal.command(name="remove-studies")
@click.argument('portal', required=True,
                type=click.Choice(Portal.list_portals()))
@click.argument('studies', required=True, type=int, nargs=-1)
def remove_study(portal, studies):
    try:
        Portal(portal).remove_studies(studies)
    except QiitaDBError as e:
        raise click.BadOptionUsage("studies", str(e))

# #############################################################################
# EBI COMMANDS
# #############################################################################


@ebi.command()
@click.option('--preprocessed_data_id', required=True, type=int)
@click.option('--action', type=click.Choice(EBISubmission.valid_ebi_actions),
              default='submit', help='The generated XML files will specify '
              'this "action", which controls how the EBI servers handle the '
              'metadata')
@click.option('--send/--no-send', default=False, help="Controls whether or "
              "not sequence files and metadata will actually be sent to EBI "
              "(default is to generate all the files, but not to send)")
@click.option('--fastq-dir', type=click.Path(exists=True, file_okay=False,
                                             resolve_path=True))
def submit(preprocessed_data_id, action, send, fastq_dir):
    _submit_EBI(preprocessed_data_id, action, send, fastq_dir)


# #############################################################################
# MAINTENANCE COMMANDS
# #############################################################################


@maintenance.command()
@click.option('--time', required=True, type=int,
              help='The amount of time to lock the site, in seconds')
@click.option('--message', required=True, type=str,
              help="Message to show users")
def lock(message, time):
    r_client.setex('maintenance', message, time)


@maintenance.command()
def unlock():
    r_client.delete('maintenance')


@maintenance.command()
@click.option('--time', required=True, type=int,
              help='The amount of time to show message, in seconds')
@click.option('--message', required=True, type=str,
              help="Message to show users")
@click.option('--banner', is_flag=True,
              help="If set, show as site banner instead of a standard message")
def sysmessage(message, time, banner):
    if banner:
        r_client.setex('sysmessage', message, time)
    else:
        expires = datetime.now() + timedelta(seconds=time)
        add_system_message(message, expires)


@maintenance.command()
def clear_sysmessage():
    r_client.delete('sysmessage')
    clear_system_messages()


@maintenance.command()
def status():
    maint_status = r_client.get('maintenance')
    sys_status = r_client.get('sysmessage')

    if maint_status is None:
        click.echo("Site is not in maintenance mode")
    else:
        click.echo("Site is in maintenance mode:")
        click.echo(maint_status)
        click.echo(r_client.ttl('maintenance'), "seconds remaining")

    if sys_status is None:
        click.echo("Site has no system message")
    else:
        click.echo("Site has system message:")
        click.echo(sys_status)
        click.echo(r_client.ttl('sysmessage'), "seconds remaining")


@maintenance.command()
@click.option('--n', required=False, type=click.IntRange(0, None), default=10,
              help="Number of most recent log entries to retrieve.",
              show_default=True)
def log(n):

    width = click.get_terminal_size()[0]

    template = width*"=" + "\nTime: {}\nMessage:\n{}\nInfo:{}\n"

    lines = []
    for e in LogEntry.newest_records(n):

        info = []
        for i in e.info:
            for field, value in viewitems(i):
                info.append('{}:{}'.format(field, value))

        lines.append(template.format(e.time, e.msg, '\n'.join(info)))

    click.echo_via_pager('\n'.join(lines))

# #############################################################################
# WEBSERVER COMMANDS
# #############################################################################


@webserver.command()
@click.option('--port', required=False, type=int, help='Port where the '
              'webserver will start', default=21174)
# (cursive Q)iita = 21174 in 1337sp34k
def start(port):
    # in order to use this command you need to have an IPython cluster running,
    # for now this makes it so that you can use other sub-commands without
    # having to do that. The solution will (perhaps) be to move this subcommand
    # into an entirely different script.
    from qiita_pet.webserver import Application
    from tornado.options import options, parse_command_line

    if qiita_config.log_path:
        options.log_file_prefix = qiita_config.log_path
        options.logging = 'warning'
        parse_command_line()
    http_server = tornado.httpserver.HTTPServer(Application())

    try:
        http_server.listen(port)
    except socket.error as e:
        if e.errno == errno.EADDRINUSE:
            raise ValueError(
                "Port %d is already in use. Please choose another port with "
                "--port." % port)
        else:
            raise

    click.echo("Qiita started on port %d" % port)
    tornado.ioloop.IOLoop.instance().start()


# #############################################################################
# WARE COMMANDS
# #############################################################################

@ware.command()
@click.argument('sl_out_dir', required=True,
                type=click.Path(resolve_path=True, readable=True, exists=True,
                                file_okay=False))
def generate_demux(sl_out_dir):
    """Generates the demux file for the split libraries output sl_out_dir"""
    demux_fp = generate_demux_file(sl_out_dir)
    click.echo("Demux file successfully generated: %s" % demux_fp)

if __name__ == '__main__':
    qiita()
